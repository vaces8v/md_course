Python — это высокоуровневый язык программирования общего назначения, который был создан Гвидо ван Россумом и выпущен в 1991 году. Он известен своим простым и понятным синтаксисом, который делает его отличным выбором как для начинающих, так и для опытных разработчиков.
### Особенности Python
1. **Простота и читаемость**
	- Python имеет минималистичный синтаксис, который близок к естественному языку. Это делает код легко читаемым и понятным.
2. **Интерпретируемый язык**
	- Python не требует компиляции перед запуском. Код выполняется построчно через интерпретатор, что ускоряет процесс разработки и отладки.
3. **Динамическая типизация**
	- Типы переменных определяются автоматически во время выполнения программы. Это упрощает написание кода, но требует внимательности к типам данных.
4. **Кроссплатформенность**
	- Python работает на разных операционных системах (Windows, macOS, Linux) без необходимости изменять код.
5. **Большое количество библиотек**
	- Python имеет богатую стандартную библиотеку, а также множество сторонних библиотек для решения практически любых задач: от веб-разработки до машинного обучения.
    
6. **Поддержка нескольких парадигм программирования**
	- Python поддерживает:
	    - **Процедурное программирование** (последовательное выполнение инструкций).
	    - **Объектно-ориентированное программирование** (ООП).
	    - **Функциональное программирование** (использование функций как объектов).
7. **Автоматическое управление памятью**
	- В Python используется сборщик мусора (garbage collector), который автоматически освобождает память, когда объекты больше не используются.



#### Разные приколы
##### Функция ID():
Возвращает идентификатор объекта
##### Функция print():
Принимает в себя огромное количество строк, чисел, других типов данных и переменных.
`end=""` - указывает какой строчкой будет оканчиваться вывод, по умолчанию `\n`
##### del statement:
Существует способ удалить элемент из списка, учитывая его индекс, а не значение: `del` оператор. Это отличается от `pop()` метода, который возвращает значение. Оператор `del` также может использоваться для удаления фрагментов из списка или очистки всего списка (что мы делали ранее, присваивая фрагменту пустой список).
`del` также может использоваться для удаления целых переменных, после чего обращаться к переменной нельзя будет.
#### Текст:
Можно использовать необработанные строки используя `r`, но при этом количество `\` должно быть чётным.
```python
print('C:\some\name')  # здесь \n означает новую строку!

print(r'C:\some\name')  # обратите внимание на r перед кавычкой
```
---
Строковые литералы могут занимать несколько строк. Один из способов — использовать тройные кавычки: `"""..."""` или `'''...'''`. Символы конца строки автоматически включаются в строку, но это можно предотвратить, добавив `\` в конце строки. В следующем примере начальный символ новой строки не учитывается:
```python
print("""\
Использование: thingy [ПАРАМЕТРЫ]
-h Отобразить это использование мнеssage
-H имя хоста, Имя хоста для подключиться к
""")
```
---
Два или более _строковых литерала_ (то есть заключённых в кавычки) рядом друг с другом автоматически объединяются.
```python
'Py' 'thon'
```
Эта функция особенно полезна, когда вы хотите разорвать длинные строки

---
Строки в Python не изменяемые.

---

#### Инструменты управления потоком:
##### if:
Пожалуй, самый известный тип операторов — это оператор `if` . Например:
```python
x = int(input("Пожалуйста, введите целое число: "))

if x < 0:
    x = 0
    print('Отрицательное значение изменено на ноль')
elif x == 0:
    print('Ноль')
elif x == 1:
    print('Один')
else:
    print('Больше')
```
Может быть ноль или более частей `elif` с фигурными скобками, причём часть `else` необязательна. Ключевое слово «`elif`» является сокращением от «else if» и используется для того, чтобы избежать чрезмерных отступов. Последовательность `if` … `elif` … `elif` … заменяет операторы `switch` или `case` в других языках.
##### match-case:
Оператор `switch-case` в Python долгое время его не было и использовалась конструкция:
```python
if (...):
	pass
elif (...):
	pass
elif (...):
	pass
```
С Python 3.10 была добавлена конструкция `match-case`. Вот пример:
```python
def http_error(status):
    match status:
        case 400:
            return "Bad request"
        case 404:
            return "Not found"
        case 418:
            return "I'm a teapot"
        case _:
            return "Something's wrong with the internet"
```
Обратите внимание на последний блок: «имя переменной» `_`действует как _подстановочный знак_ и никогда не приводит к ошибке. Если ни один из вариантов не подходит, ни одна из ветвей не выполняется.
Вы можете объединить несколько литералов в один шаблон с помощью `|` («или»):
```python
case 401 | 403 | 404:
    return «Не разрешено»
```
Мы можем добавить к шаблону условие `if` , известное как «охрана». Если условие охраны ложно, `match` выполняется следующий блок. Обратите внимание, что захват значения происходит до оценки условия охраны:
```python
match point:
    case Point(x, y) if x == y:
        print(f"Y=X at {x}")
    case Point(x, y):
        print(f"Not on the diagonal")
```
Мы можем добавить к шаблону условие `if` , известное как «охрана». Если условие охраны ложно, `match` выполняется следующий блок. Обратите внимание, что захват значения происходит до оценки условия охраны:
```python
match point:
    case Point(x, y) if x == y:
        print(f"Y=X at {x}")
    case Point(x, y):
        print(f"Not on the diagonal")
```


##### for:
Оператор `for` в Python немного отличается от того, к чему вы, возможно, привыкли в C или Pascal. Вместо того, чтобы всегда перебирать арифметическую прогрессию чисел (как в Pascal) или давать пользователю возможность определять как шаг итерации, так и условие завершения (как в C), оператор `for` в Python перебирает элементы любой последовательности (списка или строки) в том порядке, в котором они появляются в последовательности.
```python
for i in range(2, 10, 2):
	pass
else:
	pass
```

##### Функции:
```python
def fun(arg):
	pass
```
###### Специальные параметры:
```python
def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
	pass
```
где `/` и `*` являются необязательными. Если они используются, эти символы указывают на тип параметра, с помощью которого аргументы могут быть переданы в функцию: только позиционные, позиционно-ключевые и только ключевые. Ключевые параметры также называют именованными.
Если рассмотреть это более подробно, то можно отметить, что некоторые параметры являются _позиционными_. Если _позиционные_, то порядок параметров имеет значение, и параметры не могут быть переданы с помощью ключевых слов. Позиционные параметры указываются перед `/` (прямой косой чертой). `/` Косая черта используется для логического отделения позиционных параметров от остальных. Если в определении функции нет `/` позиционных параметров, то их нет и в списке.
Чтобы пометить параметры как _ключевые_, указав, что они должны передаваться в качестве ключевых аргументов, поместите `*`в список аргументов сразу перед первым _ключевым_ параметром.
Пример:
```python
def standard_arg(arg):
    print(arg)

def pos_only_arg(arg, /):
    print(arg)

def kwd_only_arg(*, arg):
    print(arg)

def combined_example(pos_only, /, standard, *, kwd_only):
    print(pos_only, standard, kwd_only)
```
Первое определение функции, `standard_arg` наиболее привычная форма, не накладывает ограничений на соглашение о вызове, и аргументы могут передаваться по позиции или по ключевому слову:
```python
>>> standard_arg(2)
2

>>> standard_arg(arg=2)
2
```
Вторая функция `pos_only_arg` может использовать только позиционные параметры, так как в определении функции есть `/` :
```python
>>> pos_only_arg(1)
1

>>> pos_only_arg(arg=1)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: pos_only_arg() got some positional-only arguments passed as keyword arguments: 'arg'
```
Третья функция `kwd_only_arg` допускает только аргументы по ключевым словам, как указано в `*` определении функции:
```python
>>> kwd_only_arg(3)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: kwd_only_arg() takes 0 positional arguments but 1 was given

>>> kwd_only_arg(arg=3)
3
```
И последнее использует все три соглашения о вызовах в одном и том же определении функции:
```python
>>> combined_example(1, 2, 3)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: combined_example() takes 2 positional arguments but 3 were given

>>> combined_example(1, 2, kwd_only=3)
1 2 3

>>> combined_example(1, standard=2, kwd_only=3)
1 2 3

>>> combined_example(pos_only=1, standard=2, kwd_only=3)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only'
```
###### Документация функций:
Вот некоторые соглашения о содержании и форматировании строк документации.
Первая строка всегда должна быть кратким и лаконичным описанием назначения объекта. Для краткости в ней не следует указывать название или тип объекта, поскольку они доступны другими способами (за исключением случаев, когда название является глаголом, описывающим работу функции). Эта строка должна начинаться с заглавной буквы и заканчиваться точкой.
Если в строке документации есть дополнительные строки, вторая строка должна быть пустой, визуально отделяя краткое описание от остальной части. Следующие строки должны представлять собой один или несколько абзацев, описывающих правила вызова объекта, его побочные эффекты и т. д.
Парсер Python не удаляет отступы из многострочных строковых литералов в Python, поэтому инструменты, обрабатывающие документацию, при необходимости должны удалять отступы. Это делается с помощью следующего соглашения. Первая непустая строка _после_ первой строки строки определяет размер отступа для всей строки документации. (Мы не можем использовать первую строку, так как она обычно находится рядом с открывающими кавычками строки, поэтому её отступ не виден в строковом литерале.) Пробелы, «эквивалентные» этому отступу, затем удаляются из начала всех строк в строке. Строки с меньшим отступом не должны встречаться, но если они встречаются, то все ведущие пробелы должны быть удалены. Эквивалентность пробелов следует проверять после расширения вкладок (обычно до 8 пробелов).
Вот пример многострочной строки документации:
```python
def my_function():
    """Do nothing, but document it.

 No, really, it doesn't do anything.
 """
    pass

print(my_function.__doc__)
```
###### Аннотации к функциям:
Аннотации функций — это необязательная информация о типах, используемых пользовательскими функциями
Аннотации хранятся в `__annotations__` атрибуте функции в виде словаря и не влияют ни на какую другую часть функции. Аннотации параметров определяются двоеточием после имени параметра, за которым следует выражение, вычисляющее значение аннотации. Аннотации возвращаемых значений определяются литералом `->`, за которым следует выражение, между списком параметров и двоеточием, обозначающим конец `def` оператора. В следующем примере есть обязательный аргумент, необязательный аргумент и аннотированное возвращаемое значение:
```python
def f(ham: str, eggs: str = 'eggs') -> str:
    print("Annotations:", f.__annotations__)
    print("Arguments:", ham, eggs)
    return ham + ' and ' + eggs

f('spam')
```
#### Распаковка списков аргументов:
Обратная ситуация возникает, когда аргументы уже находятся в списке или кортеже, но их нужно распаковать для вызова функции, требующей отдельные позиционные аргументы. Например, встроенная функция `range()` ожидает отдельные аргументы _start_ и _stop_. Если они недоступны по отдельности, напишите вызов функции с оператором `*` для распаковки аргументов из списка или кортежа:
```python
list(range(3, 6))            # normal call with separate arguments

args = [3, 6]
list(range(*args))            # call with arguments unpacked from a list
```
Таким же образом словари могут передавать аргументы по ключевым словам с помощью `**`-оператора:
```python
def parrot(voltage, state='a stiff', action='voom'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.", end=' ')
    print("E's", state, "!")

d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
parrot(**d)
```
##### Лямбда функции:
Небольшие анонимные функции можно создавать с помощью `lambda` ключевого слова. Эта функция возвращает сумму двух своих аргументов: `lambda a, b: a+b`. Лямбда-функции можно использовать везде, где требуются функциональные объекты. С точки зрения синтаксиса они ограничены одним выражением. С точки зрения семантики они являются просто синтаксическим сахаром для обычного определения функции. Как и вложенные определения функций, лямбда-функции могут ссылаться на переменные из содержащей области видимости:
```python
def make_incrementor(n):
    return lambda x: x + n

f = make_incrementor(42)
f(0)

f(1)
```
В приведенном выше примере используется лямбда-выражение для возврата функции. Другой вариант использования — передача небольшой функции в качестве аргумента:
```python
pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
pairs.sort(key=lambda pair: pair[1])
pairs
```
##### Техники зацикливания
При переборе словарей ключ и соответствующее ему значение можно получить одновременно с помощью метода `items()`.
```python
knights = {'gallahad': 'the pure', 'robin': 'the brave'}
for k, v in knights.items():
    print(k, v)
```
При переборе последовательности индекс позиции и соответствующее значение можно получить одновременно с помощью функции `enumerate()`
```python
for i, v in enumerate(['tic', 'tac', 'toe']):
    print(i, v)
```
Чтобы одновременно перебирать две или более последовательностей, записи можно объединить с помощью функции `zip()`
```python
questions = ['name', 'quest', 'favorite color']
answers = ['lancelot', 'the holy grail', 'blue']
for q, a in zip(questions, answers):
    print('What is your {0}? It is {1}.'.format(q, a))
```
Чтобы выполнить цикл по последовательности в обратном направлении, сначала укажите последовательность в прямом направлении, а затем вызовите функцию `reversed()`
```python
for i in reversed(range(1, 10, 2)):
    print(i)
```
Чтобы перебрать последовательность в отсортированном порядке, используйте функцию `sorted()`, которая возвращает новый отсортированный список, оставляя исходный список без изменений.
```python
basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
for i in sorted(basket):
    print(i)
```
Использование `set()` в последовательности устраняет повторяющиеся элементы. Использование `sorted()` в сочетании с `set()` "установленный") в последовательности — это идиоматический способ перебора уникальных элементов последовательности в отсортированном порядке.
```python
basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
for f in sorted(set(basket)):
    print(f)
```
